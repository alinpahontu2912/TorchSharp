################################################################################
# TorchSharp's PR validation build
################################################################################
# 
# IMPORTANT: This pipeline uses Build Artifacts (PublishBuildArtifacts/DownloadBuildArtifacts)
# instead of Pipeline Artifacts to avoid dedup/hydration issues with large artifacts (3-8GB).
# All artifacts are compressed before upload for improved reliability and stability.
#
################################################################################

name: $(TeamProject)_$(Build.DefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  # Set this to 'true' to build the libtorch-* packages as part of main branch CI and
  # push them to the artifacts feed of the Azure CI project
  - name: BuildLibTorchPackages
    type: boolean
    default: true
  - name: PushPackagesToFeed
    type: boolean
    default: false

  # Set which source branch to build libtorch-* packages.
  # The build-libtorch jobs are only run if the source branch is the same as this value.
  # The default is 'main' branch.
  - name: SourceBranchName
    type: string
    default: 'main'

variables:
  MyRunNumber:  $[counter('MyRunNumber', 52201)]
  LinuxPrepScript: |
    ldd --version && (/sbin/ldconfig -p | grep stdc++) && (strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep LIBCXX)
    sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys DE19EB17684BA42D
    sudo apt-get -y update
    sudo apt-get -y install cmake clang git libunwind8 curl libomp-dev libomp5 wget
    wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
    sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
    sudo apt-get update; sudo apt-get install -y apt-transport-https && sudo apt-get update
    ldd --version && (/sbin/ldconfig -p | grep stdc++) && (strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep LIBCXX)

resources:
  containers:
#   - container: CentosContainer
#     image: mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7-mlnet-8bba86b-20190314145033
# dotnet-buildtools/prereqs containers can be browsed at
#   https://github.com/dotnet/versions/blob/main/build-info/docker/image-info.dotnet-dotnet-buildtools-prereqs-docker-main.json

   - container: UbuntuContainer
     image: mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-20.04-20240708213715-dcf0bb9

jobs:
- template: /build/ci/job-template.yml
  parameters:
    name: Ubuntu_x64
    # This reports the GLIB_ and GLIBCXX_ dependencies on the system which ends up getting baked into
    # the generated libTorchSharp.so (and partly determines which Linux systems that binary will
    # be usable on), then installs clang-7.0 (LibTorch likes this for building C++ 14), then installs .NET 6.0
    prepScript: ${{ variables.LinuxPrepScript }}
    buildScript: dotnet build /p:SkipCuda=true -c
    testScript: dotnet test /p:SkipCuda=true --blame test/TorchSharpTest/TorchSharpTest.csproj -c
    pool:
      vmImage: 'ubuntu-latest'
    container: UbuntuContainer

- template: /build/ci/job-template.yml
  parameters:
    prepScript: echo "no prep needed"
    name: Windows_x64_NetCore
    buildScript: dotnet build /p:SkipCuda=true /p:SkipNetFxBuild=true -c
    testScript: dotnet test /p:SkipCuda=true /p:SkipNetFxBuild=true --blame test\TorchSharpTest\TorchSharpTest.csproj -c
    pool:
      vmImage: 'windows-latest'

- template: /build/ci/job-template.yml
  parameters:
    prepScript: echo "no prep needed"
    name: Windows_x64_NetFX
    buildScript: dotnet build /p:SkipCuda=true /p:SkipNetCoreBuild=true -c
    testScript: dotnet test /p:SkipCuda=true /p:SkipNetCoreBuild=true --blame test\TorchSharpTest\TorchSharpTest.csproj -c
    pool:
      vmImage: 'windows-latest'

- template: /build/ci/job-template.yml
  parameters:
    prepScript: echo "no prep needed"
    name: MacOS_arm64
    buildScript: dotnet build /p:SkipCuda=true /p:TargetArchitecture=arm64 -c
    testScript: echo "Azure Pipelines does not support arm64 yet, can't run tests"
    pool:
      vmImage: 'macos-latest'

################################################################################
# {Build} --> combine --> package to build native bits on multiple OS's
################################################################################


################################################################################
- job: Linux_Native_Build_For_Packages
################################################################################
  condition: and(ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'))
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'ubuntu-latest'
  container: UbuntuContainer
  steps:
  # Initial cleanup
  - script: |
      rm -rf bin/obj
      find . -name "*.pdb" -type f -delete
      find . -name "*.xml" -type f -delete
      df -h
    displayName: Initial cleanup and check disk space
    continueOnError: true

  - task: UseDotNet@2
    displayName: 'Use .NET Core sdk'
    inputs:
      packageType: sdk
      version: 6.0.402
      installationPath: $(Agent.ToolsDirectory)/dotnet

  - script: ${{ variables.LinuxPrepScript }}
    displayName: Install dependencies

  # Build libtorch CPU and clean immediately
  - script: |
      dotnet build -c $(BuildConfig) src/Redist/libtorch-cpu/libtorch-cpu.proj /p:UpdateSHA=true /p:SkipTests=true /p:TargetOS=linux /t:Build /p:IncludeLibTorchCpuPackages=true
      # Clean up downloaded archives after extraction
      find . -name "*.zip" -type f -delete
      find . -name "*.tar.gz" -type f -delete
    condition: eq('${{ parameters.BuildLibTorchPackages }}', true)
    displayName: Download libtorch native binaries and cleanup archives

  # Build libtorch CUDA and clean immediately
  - script: |
      dotnet build -c $(BuildConfig) src/Redist/libtorch-cuda-12.8/libtorch-cuda-12.8.proj /p:UpdateSHA=true /p:SkipTests=true /p:TargetOS=linux /t:Build /p:IncludeLibTorchCudaPackages=true
      # Clean up downloaded archives after extraction
      find . -name "*.zip" -type f -delete
      find . -name "*.tar.gz" -type f -delete
    condition: eq('${{ parameters.BuildLibTorchPackages }}', true)
    displayName: Download libtorch CUDA binaries and cleanup archives

  - script: dotnet build -c $(BuildConfig) src/TorchSharp/TorchSharp.csproj /p:SkipCuda=true /p:SkipTests=true
    displayName: Build TorchSharp

  - script: dotnet build -c $(BuildConfig) src/TorchVision/TorchVision.csproj /p:SkipCuda=true /p:SkipTests=true
    displayName: Build TorchVision

  - script: dotnet build -c $(BuildConfig) src/TorchAudio/TorchAudio.csproj /p:SkipCuda=true /p:SkipTests=true
    displayName: Build TorchAudio

  # Clean up unnecessary files before publishing
  - script: |
      find $(Build.SourcesDirectory)/bin -name "*.pdb" -type f -delete
      find $(Build.SourcesDirectory)/bin -name "*.xml" -type f -delete
      rm -rf $(Build.SourcesDirectory)/bin/obj/packprep/$(BuildConfig)/**/*.a
      df -h
    displayName: Clean up unnecessary files before publish
    continueOnError: true

  # CHANGED: Compress artifacts before publishing to avoid dedup/hydration issues
  # Using tar.gz for Linux artifacts - simple blob upload is more reliable than dedup
  - script: |
      cd $(Build.SourcesDirectory)/bin/obj/packprep/$(BuildConfig)
      mkdir -p $(Build.ArtifactStagingDirectory)/LinuxAssets
      # Compress TorchSharp separately
      if [ -d "TorchSharp" ]; then
        tar -czvf $(Build.ArtifactStagingDirectory)/LinuxAssets/TorchSharp.tar.gz TorchSharp
      fi
      # Compress TorchAudio separately
      if [ -d "TorchAudio" ]; then
        tar -czvf $(Build.ArtifactStagingDirectory)/LinuxAssets/TorchAudio.tar.gz TorchAudio
      fi
      # Compress TorchVision separately
      if [ -d "TorchVision" ]; then
        tar -czvf $(Build.ArtifactStagingDirectory)/LinuxAssets/TorchVision.tar.gz TorchVision
      fi
      # Compress libtorch-cpu assets separately if they exist
      for dir in libtorch-cpu-*; do
        if [ -d "$dir" ]; then
          tar -czvf $(Build.ArtifactStagingDirectory)/LinuxAssets/${dir}.tar.gz "$dir"
        fi
      done
      # Compress libtorch-cuda assets separately if they exist
      for dir in libtorch-cuda-*; do
        if [ -d "$dir" ]; then
          tar -czvf $(Build.ArtifactStagingDirectory)/LinuxAssets/${dir}.tar.gz "$dir"
        fi
      done
      ls -lh $(Build.ArtifactStagingDirectory)/LinuxAssets/
      df -h
    displayName: Compress Linux assets for stable upload

  # CHANGED: Use PublishBuildArtifacts instead of publish (PublishPipelineArtifact)
  # Build Artifacts use simple file blob storage - no dedup/hydration issues
  - task: PublishBuildArtifacts@1
    displayName: Publish Linux Assets (Build Artifact)
    inputs:
      pathToPublish: $(Build.ArtifactStagingDirectory)/LinuxAssets
      artifactName: LinuxAssets
      parallel: false  # Disable parallel upload for stability with large files

################################################################################
- job: Windows_Native_Build_For_Packages
################################################################################
  condition: and(ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'))
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'windows-latest'
  steps:
  # Initial cleanup
  - script: |
      rmdir /s /q .git 2>nul
      dotnet nuget locals all --clear
      dir
    displayName: Initial cleanup
    continueOnError: true

  - task: UseDotNet@2
    displayName: 'Use .NET Core sdk'
    inputs:
      packageType: sdk
      version: 6.0.402
      installationPath: $(Agent.ToolsDirectory)/dotnet

  # Build libtorch CPU and clean immediately
  - script: |
      dotnet build -c $(BuildConfig) src/Redist/libtorch-cpu/libtorch-cpu.proj /p:UpdateSHA=true /p:SkipTests=true /p:TargetOS=windows /t:Build /p:IncludeLibTorchCpuPackages=true
      del /s /q *.zip 2>nul
      del /s /q *.tar.gz 2>nul
    displayName: Download libtorch native binaries and cleanup
    condition: eq('${{ parameters.BuildLibTorchPackages }}', true)

  # Build libtorch CUDA and clean immediately  
  - script: |
      dotnet build -c $(BuildConfig) src/Redist/libtorch-cuda-12.8/libtorch-cuda-12.8.proj /p:UpdateSHA=true /p:SkipTests=true /p:TargetOS=windows /t:Build /p:IncludeLibTorchCudaPackages=true
      del /s /q *.zip 2>nul
      del /s /q *.tar.gz 2>nul
    condition: eq('${{ parameters.BuildLibTorchPackages }}', true)
    displayName: Download libtorch CUDA binaries and cleanup

  - script: dotnet build -c $(BuildConfig) src/TorchSharp/TorchSharp.csproj /p:SkipCuda=true /p:SkipTests=true
    condition: eq('${{ parameters.BuildLibTorchPackages }}', true)
    displayName: Build TorchSharp

  - script: dotnet build -c $(BuildConfig) src/TorchVision/TorchVision.csproj /p:SkipCuda=true /p:SkipTests=true
    displayName: Build TorchVision

  - script: dotnet build -c $(BuildConfig) src/TorchAudio/TorchAudio.csproj /p:SkipCuda=true /p:SkipTests=true
    displayName: Build TorchAudio

  # Clean up unnecessary files before publishing
  - script: |
      del /s /q $(Build.SourcesDirectory)\bin\*.pdb 2>nul
      del /s /q $(Build.SourcesDirectory)\bin\*.xml 2>nul
      del /s /q $(Build.SourcesDirectory)\bin\obj\packprep\$(BuildConfig)\*.lib 2>nul
    displayName: Clean up unnecessary files
    continueOnError: true

  # CHANGED: Compress artifacts before publishing to avoid dedup/hydration issues
  # Using 7z for Windows artifacts - produces smaller archives and is reliable
  - task: PowerShell@2
    displayName: Compress Windows assets for stable upload
    inputs:
      targetType: 'inline'
      script: |
        $sourceDir = "$(Build.SourcesDirectory)\bin\obj\packprep\$(BuildConfig)"
        $destDir = "$(Build.ArtifactStagingDirectory)\WindowsAssets"
        New-Item -ItemType Directory -Force -Path $destDir | Out-Null
        
        # Compress TorchSharp
        if (Test-Path "$sourceDir\TorchSharp") {
          Write-Host "Compressing TorchSharp..."
          7z a -tzip "$destDir\TorchSharp.zip" "$sourceDir\TorchSharp" -mx=5
        }
        # Compress TorchAudio
        if (Test-Path "$sourceDir\TorchAudio") {
          Write-Host "Compressing TorchAudio..."
          7z a -tzip "$destDir\TorchAudio.zip" "$sourceDir\TorchAudio" -mx=5
        }
        # Compress TorchVision
        if (Test-Path "$sourceDir\TorchVision") {
          Write-Host "Compressing TorchVision..."
          7z a -tzip "$destDir\TorchVision.zip" "$sourceDir\TorchVision" -mx=5
        }
        # Compress libtorch-cpu assets
        Get-ChildItem -Path $sourceDir -Directory -Filter "libtorch-cpu-*" | ForEach-Object {
          Write-Host "Compressing $($_.Name)..."
          7z a -tzip "$destDir\$($_.Name).zip" "$($_.FullName)" -mx=5
        }
        # Compress libtorch-cuda assets
        Get-ChildItem -Path $sourceDir -Directory -Filter "libtorch-cuda-*" | ForEach-Object {
          Write-Host "Compressing $($_.Name)..."
          7z a -tzip "$destDir\$($_.Name).zip" "$($_.FullName)" -mx=5
        }
        
        Write-Host "Compressed files:"
        Get-ChildItem $destDir | Format-Table Name, Length

  # CHANGED: Use PublishBuildArtifacts instead of publish (PublishPipelineArtifact)
  # Build Artifacts use simple file blob storage - no dedup/hydration issues
  - task: PublishBuildArtifacts@1
    displayName: Publish Windows Assets (Build Artifact)
    inputs:
      pathToPublish: $(Build.ArtifactStagingDirectory)/WindowsAssets
      artifactName: WindowsAssets
      parallel: false  # Disable parallel upload for stability with large files

################################################################################
- job: MacOS_arm64_Native_Build_For_Packages
################################################################################
  condition: and(ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'))
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
    CMAKE_POLICY_VERSION_MINIMUM: 3.5
  pool:
    vmImage: 'macos-latest'
  steps:
  # Initial cleanup
  - script: |
      rm -rf .git
      dotnet nuget locals all --clear
      # Check CMake version and update if needed
      cmake --version || brew install cmake
      brew upgrade cmake || true
      cmake --version
      df -h
    displayName: Initial cleanup and setup
    continueOnError: true

  # Build and clean archives immediately
  - script: |
      dotnet build -c $(BuildConfig) src/Redist/libtorch-cpu/libtorch-cpu.proj /p:UpdateSHA=true /p:TargetOS=mac /p:TargetArchitecture=arm64 /t:Build /p:IncludeLibTorchCpuPackages=true /p:CmakePolicyVersionMinimum=3.5
      find . -name "*.zip" -type f -delete
      find . -name "*.tar.gz" -type f -delete
    displayName: Download libtorch native binaries and cleanup
    condition: eq('${{ parameters.BuildLibTorchPackages }}', true)

  - script: dotnet build -c $(BuildConfig) src/TorchSharp/TorchSharp.csproj /p:SkipCuda=true /p:SkipTests=true /p:TargetArchitecture=arm64 /p:CmakePolicyVersionMinimum=3.5
    displayName: Build TorchSharp mac-arm64

  - script: dotnet build -c $(BuildConfig) src/TorchVision/TorchVision.csproj /p:SkipCuda=true /p:SkipTests=true /p:TargetArchitecture=arm64 /p:CmakePolicyVersionMinimum=3.5
    displayName: Build TorchVision

  - script: dotnet build -c $(BuildConfig) src/TorchAudio/TorchAudio.csproj /p:SkipCuda=true /p:SkipTests=true /p:TargetArchitecture=arm64 /p:CmakePolicyVersionMinimum=3.5
    displayName: Build TorchAudio

  # Clean up before publishing
  - script: |
      find $(Build.SourcesDirectory)/bin -name "*.pdb" -type f -delete
      find $(Build.SourcesDirectory)/bin -name "*.xml" -type f -delete
      df -h
    displayName: Clean up unnecessary files
    continueOnError: true

  # CHANGED: Compress artifacts before publishing to avoid dedup/hydration issues
  # Using tar.gz for macOS artifacts - simple blob upload is more reliable than dedup
  - script: |
      cd $(Build.SourcesDirectory)/bin/obj/packprep/$(BuildConfig)
      mkdir -p $(Build.ArtifactStagingDirectory)/MacAssets_arm64
      # Compress TorchSharp separately
      if [ -d "TorchSharp" ]; then
        tar -czvf $(Build.ArtifactStagingDirectory)/MacAssets_arm64/TorchSharp.tar.gz TorchSharp
      fi
      # Compress TorchAudio separately
      if [ -d "TorchAudio" ]; then
        tar -czvf $(Build.ArtifactStagingDirectory)/MacAssets_arm64/TorchAudio.tar.gz TorchAudio
      fi
      # Compress TorchVision separately
      if [ -d "TorchVision" ]; then
        tar -czvf $(Build.ArtifactStagingDirectory)/MacAssets_arm64/TorchVision.tar.gz TorchVision
      fi
      # Compress libtorch-cpu assets separately if they exist
      for dir in libtorch-cpu-*; do
        if [ -d "$dir" ]; then
          tar -czvf $(Build.ArtifactStagingDirectory)/MacAssets_arm64/${dir}.tar.gz "$dir"
        fi
      done
      ls -lh $(Build.ArtifactStagingDirectory)/MacAssets_arm64/
      df -h
    displayName: Compress Mac assets for stable upload

  # CHANGED: Use PublishBuildArtifacts instead of publish (PublishPipelineArtifact)
  # Build Artifacts use simple file blob storage - no dedup/hydration issues
  - task: PublishBuildArtifacts@1
    displayName: Publish Mac Assets (Build Artifact)
    inputs:
      pathToPublish: $(Build.ArtifactStagingDirectory)/MacAssets_arm64
      artifactName: MacAssets_arm64
      parallel: false  # Disable parallel upload for stability with large files

################################################################################
- job: Build_TorchSharp_And_libtorch_cpu_Packages
################################################################################
  condition: and(ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'))
  dependsOn:
  - Linux_Native_Build_For_Packages
  - Windows_Native_Build_For_Packages
  - MacOS_arm64_Native_Build_For_Packages
  timeoutInMinutes: 90
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'windows-latest'
  steps:

  # We are 10GB space-constrained on the Azure Pipelines CI system so clean up what we can
  # yup we even nuke the .git
  - script: rmdir /q /s .git
    displayName: Clean up space (.git)
    continueOnError: true

  # CHANGED: Use DownloadBuildArtifacts instead of DownloadPipelineArtifact
  # Download compressed Linux assets - Build Artifacts are more stable for large files
  - task: DownloadBuildArtifacts@1
    displayName: Download Linux Assets (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'LinuxAssets'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # Extract Linux assets - streaming-safe extraction
  - task: PowerShell@2
    displayName: Extract Linux assets
    inputs:
      targetType: 'inline'
      script: |
        $sourceDir = "$(Pipeline.Workspace)\LinuxAssets"
        $destDir = "$(Build.SourcesDirectory)\bin\obj\packprep\$(BuildConfig)"
        New-Item -ItemType Directory -Force -Path $destDir | Out-Null
        
        Write-Host "Extracting Linux assets from: $sourceDir"
        Get-ChildItem -Path $sourceDir -Filter "*.tar.gz" | ForEach-Object {
          Write-Host "Extracting $($_.Name)..."
          # Use tar for extraction (available on Windows 10+)
          tar -xzf $_.FullName -C $destDir
        }
        Write-Host "Extraction complete. Contents:"
        Get-ChildItem $destDir | Format-Table Name

  # Clean up compressed Linux assets immediately after extraction
  - script: rmdir /s /q $(Pipeline.Workspace)\LinuxAssets
    displayName: Clean LinuxAssets immediately
    continueOnError: true

  # CHANGED: Download Mac assets using Build Artifacts
  - task: DownloadBuildArtifacts@1
    displayName: Download Mac Assets (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'MacAssets_arm64'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # Extract Mac assets - streaming-safe extraction
  - task: PowerShell@2
    displayName: Extract Mac assets
    inputs:
      targetType: 'inline'
      script: |
        $sourceDir = "$(Pipeline.Workspace)\MacAssets_arm64"
        $destDir = "$(Build.SourcesDirectory)\bin\obj\packprep\$(BuildConfig)"
        
        Write-Host "Extracting Mac assets from: $sourceDir"
        Get-ChildItem -Path $sourceDir -Filter "*.tar.gz" | ForEach-Object {
          Write-Host "Extracting $($_.Name)..."
          tar -xzf $_.FullName -C $destDir
        }
        Write-Host "Extraction complete."

  - script: rmdir /s /q $(Pipeline.Workspace)\MacAssets_arm64
    displayName: Clean MacAssets immediately
    continueOnError: true

  # CHANGED: Download Windows assets using Build Artifacts
  - task: DownloadBuildArtifacts@1
    displayName: Download Windows Assets (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'WindowsAssets'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # Extract Windows assets - streaming-safe extraction using 7z
  - task: PowerShell@2
    displayName: Extract Windows assets
    inputs:
      targetType: 'inline'
      script: |
        $sourceDir = "$(Pipeline.Workspace)\WindowsAssets"
        $destDir = "$(Build.SourcesDirectory)\bin\obj\packprep\$(BuildConfig)"
        
        Write-Host "Extracting Windows assets from: $sourceDir"
        Get-ChildItem -Path $sourceDir -Filter "*.zip" | ForEach-Object {
          Write-Host "Extracting $($_.Name)..."
          7z x $_.FullName -o"$destDir" -y
        }
        Write-Host "Extraction complete. Contents:"
        Get-ChildItem $destDir | Format-Table Name

  - script: rmdir /s /q $(Pipeline.Workspace)\WindowsAssets
    displayName: Clean WindowsAssets immediately
    continueOnError: true

  # Restore and pack
  - script: dotnet restore pkg/pack.proj /p:Configuration=Release --nologo
    displayName: Restore package projects

  - script: dotnet pack -c $(BuildConfig) --no-build -v:n /p:SkipNative=true /p:SkipTests=true /p:IncludeTorchSharpPackage=true /p:IncludeLibTorchCpuPackages=${{ parameters.BuildLibTorchPackages }} /p:GenerateCompatibilitySuppressionFile=true pkg/pack.proj
    displayName: Create Packages

  # Final cleanup before staging
  - script: |
      rmdir /q /s bin\obj
      for /d %%i in ($(Build.SourcesDirectory)\bin\packages\$(BuildConfig)\*.symbols.nupkg) do del "%%i"
    displayName: Clean up before staging
    continueOnError: true

  - task: CopyFiles@2
    displayName: Copy packaged assets to staging folder
    inputs:
      sourceFolder: $(Build.SourcesDirectory)/bin/packages/$(BuildConfig)
      targetFolder: $(Build.ArtifactStagingDirectory)
      contents: |
        **/*.nupkg
        !**/*.symbols.nupkg

  # CHANGED: Use PublishBuildArtifacts for final packages
  - task: PublishBuildArtifacts@1
    displayName: Publish build packages (Build Artifact)
    inputs:
      pathToPublish: $(Build.ArtifactStagingDirectory)
      artifactName: BuildTorchSharpPackages
      parallel: false

  # CHANGED: Publish config using Build Artifacts
  - task: PublishBuildArtifacts@1
    displayName: Publish signing config (Build Artifact)
    inputs:
      pathToPublish: $(Build.SourcesDirectory)/config
      artifactName: config
      parallel: false

################################################################################
# Only run if BuildLibTorchPackages is true
- job: Build_libtorch_cuda_win_Packages
################################################################################
  condition: and(not(canceled()), ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'), eq('${{ parameters.BuildLibTorchPackages }}', true))
  dependsOn:
  - Windows_Native_Build_For_Packages
  - Build_TorchSharp_And_libtorch_cpu_Packages
  timeoutInMinutes: 90
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'windows-latest'
  steps:
  # Aggressive cleanup
  - script: |
      rmdir /q /s bin\obj 2>nul
      del /s /q *.pdb 2>nul
      del /s /q *.xml 2>nul
    displayName: Final cleanup
    continueOnError: true

  # CHANGED: Download Windows assets using Build Artifacts (single download, no hydration issues)
  - task: DownloadBuildArtifacts@1
    displayName: Download Windows Assets (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'WindowsAssets'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # Extract only CUDA assets from the compressed archive
  - task: PowerShell@2
    displayName: Extract Windows CUDA assets
    inputs:
      targetType: 'inline'
      script: |
        $sourceDir = "$(Pipeline.Workspace)\WindowsAssets"
        $destDir = "$(Build.SourcesDirectory)\bin\obj\packprep\$(BuildConfig)"
        New-Item -ItemType Directory -Force -Path $destDir | Out-Null
        
        Write-Host "Extracting CUDA assets from: $sourceDir"
        Get-ChildItem -Path $sourceDir -Filter "libtorch-cuda*.zip" | ForEach-Object {
          Write-Host "Extracting $($_.Name)..."
          7z x $_.FullName -o"$destDir" -y
        }
        Write-Host "Extraction complete."

  - script: rmdir /s /q $(Pipeline.Workspace)\WindowsAssets
    displayName: Clean workspace immediately
    continueOnError: true

  - script: dotnet restore pkg/pack.proj /p:Configuration=Release --nologo
    displayName: Restore package projects

  - script: dotnet pack -c $(BuildConfig) --no-build -v:n /p:SkipNative=true /p:SkipTests=true /p:IncludeTorchSharpPackage=false /p:IncludeLibTorchCpuPackages=false /p:IncludeLibTorchCudaPackages=true /p:TargetOS=windows pkg/pack.proj
    displayName: Create CUDA Packages

  # Aggressive cleanup before staging
  - script: |
      rmdir /q /s bin\obj
      del /s /q *.pdb 2>nul
      del /s /q *.xml 2>nul
    displayName: Final cleanup
    continueOnError: true

  - task: CopyFiles@2
    displayName: Copy packaged assets to staging
    inputs:
      sourceFolder: $(Build.SourcesDirectory)/bin/packages/$(BuildConfig)
      targetFolder: $(Build.ArtifactStagingDirectory)
      contents: |
        *cuda*.nupkg
        !*.symbols.nupkg

  # CHANGED: Use PublishBuildArtifacts for Windows CUDA packages
  - task: PublishBuildArtifacts@1
    displayName: Publish Windows CUDA packages (Build Artifact)
    inputs:
      pathToPublish: $(Build.ArtifactStagingDirectory)
      artifactName: BuildWinCUDAPackages
      parallel: false

################################################################################
- job: Build_libtorch_cuda_linux_Packages
################################################################################
  condition: and(not(canceled()), ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'), eq('${{ parameters.BuildLibTorchPackages }}', true))
  dependsOn:
  - Linux_Native_Build_For_Packages
  - Build_libtorch_cuda_win_Packages
  timeoutInMinutes: 90
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'ubuntu-latest'
  container: UbuntuContainer
  steps:
  - task: UseDotNet@2
    displayName: 'Use .NET Core sdk'
    inputs:
      packageType: sdk
      version: 6.x
      installationPath: $(Agent.ToolsDirectory)/dotnet

  - script: ${{ variables.LinuxPrepScript }}
    displayName: Install dependencies

  # Aggressive cleanup
  - script: |
      rm -rf .git
      dotnet nuget locals all --clear
      df -h
    displayName: Final cleanup
    continueOnError: true

  # CHANGED: Download Linux assets using Build Artifacts (single download, no hydration issues)
  - task: DownloadBuildArtifacts@1
    displayName: Download Linux Assets (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'LinuxAssets'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # Extract only CUDA assets from the compressed archive
  - script: |
      mkdir -p $(Build.SourcesDirectory)/bin/obj/packprep/$(BuildConfig)
      cd $(Pipeline.Workspace)/LinuxAssets
      echo "Extracting CUDA assets..."
      for archive in libtorch-cuda*.tar.gz; do
        if [ -f "$archive" ]; then
          echo "Extracting $archive..."
          tar -xzf "$archive" -C $(Build.SourcesDirectory)/bin/obj/packprep/$(BuildConfig)
        fi
      done
      echo "Extraction complete."
      ls -la $(Build.SourcesDirectory)/bin/obj/packprep/$(BuildConfig)/
    displayName: Extract Linux CUDA assets

  - script: rm -rf $(Pipeline.Workspace)/LinuxAssets
    displayName: Clean workspace immediately
    continueOnError: true

  - script: dotnet restore pkg/pack.proj /p:Configuration=Release --nologo
    displayName: Restore package projects

  - script: dotnet pack -c $(BuildConfig) --no-build -v:n /p:SkipNative=true /p:SkipTests=true /p:ApiCompatGenerateSuppressionFile=true /p:IncludeTorchSharpPackage=false /p:IncludeLibTorchCpuPackages=false /p:IncludeLibTorchCudaPackages=true /p:TargetOS=linux pkg/pack.proj
    displayName: Create CUDA Packages

  # Final cleanup
  - script: |
      rm -rf bin/obj
      find . -name "*.pdb" -type f -delete
      find . -name "*.xml" -type f -delete
      df -h
    displayName: Final cleanup
    continueOnError: true

  - task: CopyFiles@2
    displayName: Copy packaged assets to staging
    inputs:
      sourceFolder: $(Build.SourcesDirectory)/bin/packages/$(BuildConfig)
      targetFolder: $(Build.ArtifactStagingDirectory)
      contents: |
        *cuda*.nupkg
        !*.symbols.nupkg

  # CHANGED: Use PublishBuildArtifacts for Linux CUDA packages
  - task: PublishBuildArtifacts@1
    displayName: Publish Linux CUDA packages (Build Artifact)
    inputs:
      pathToPublish: $(Build.ArtifactStagingDirectory)
      artifactName: BuildLinuxCUDAPackages
      parallel: false

################################################################################
- job: CodeSign_Core
################################################################################
  condition: and(ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'))
  dependsOn:
  - Build_TorchSharp_And_libtorch_cpu_Packages
  variables:
  - group: SignClient Credentials
  pool:
    vmImage: 'windows-latest'
  steps:

  - task: DotNetCoreCLI@2
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . --prerelease sign
    displayName: Install SignTool tool

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download configuration (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'config'
      downloadPath: $(Pipeline.Workspace)

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download TorchSharp Packages (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'BuildTorchSharpPackages'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # CHANGED: Use AzureCLI@2 task for signing - client secret is deprecated
  # Requires an Azure service connection with workload identity federation
  - task: AzureCLI@2
    displayName: Sign packages
    inputs:
      azureSubscription: '$(SignServiceConnection)'  # Set this variable to your Azure service connection name
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      inlineScript: |
        .\sign code azure-key-vault '**/*.nupkg' `
          --base-directory "$(Pipeline.Workspace)\BuildTorchSharpPackages" `
          --file-list "$(Pipeline.Workspace)\config\signedfiles.txt" `
          --azure-key-vault-url "$(SignVaultURL)" `
          --publisher-name "TorchSharp" `
          --description "TorchSharp" `
          --description-url "https://github.com/dotnet/TorchSharp" `
          --azure-key-vault-certificate "$(SignCertFriendlyName)"

  # CHANGED: Use PublishBuildArtifacts for signed packages
  - task: PublishBuildArtifacts@1
    displayName: Publish Signed TorchSharp Packages (Build Artifact)
    inputs:
      pathToPublish: $(Pipeline.Workspace)/BuildTorchSharpPackages
      artifactName: SignedTorchSharpPackages
      parallel: false
    continueOnError: true

  - script: rmdir /s /q  $(Pipeline.Workspace)\BuildTorchSharpPackages
    displayName: Free up space (TorchSharp packages in workspace)

################################################################################
- job: CodeSign_Extras
################################################################################
  condition: and(ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'), eq('${{ parameters.BuildLibTorchPackages }}', true))
  dependsOn:
  - Build_libtorch_cuda_win_Packages
  - Build_libtorch_cuda_linux_Packages
  variables:
  - group: SignClient Credentials
  pool:
    vmImage: 'windows-latest'
  steps:

  - task: DotNetCoreCLI@2
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . --prerelease sign
    displayName: Install SignTool tool

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download configuration (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'config'
      downloadPath: $(Pipeline.Workspace)

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download Windows CUDA Packages (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'BuildWinCUDAPackages'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # CHANGED: Use AzureCLI@2 task for signing - client secret is deprecated
  - task: AzureCLI@2
    displayName: Sign packages
    inputs:
      azureSubscription: '$(SignServiceConnection)'
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      inlineScript: |
        .\sign code azure-key-vault '**/*.nupkg' `
          --base-directory "$(Pipeline.Workspace)\BuildWinCUDAPackages" `
          --file-list "$(Pipeline.Workspace)\config\signedfiles.txt" `
          --azure-key-vault-url "$(SignVaultURL)" `
          --publisher-name "TorchSharp" `
          --description "TorchSharp" `
          --description-url "https://github.com/dotnet/TorchSharp" `
          --azure-key-vault-certificate "$(SignCertFriendlyName)"

  # CHANGED: Use PublishBuildArtifacts for signed Windows CUDA packages
  - task: PublishBuildArtifacts@1
    displayName: Publish Signed Windows CUDA Packages (Build Artifact)
    inputs:
      pathToPublish: $(Pipeline.Workspace)/BuildWinCUDAPackages
      artifactName: SignedWinCUDAPackages
      parallel: false
    continueOnError: true

  - script: rmdir /s /q  $(Pipeline.Workspace)\BuildWinCUDAPackages
    displayName: Free up space (TorchSharp packages in workspace)

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download Linux CUDA Packages (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'BuildLinuxCUDAPackages'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # CHANGED: Use AzureCLI@2 task for signing - client secret is deprecated
  - task: AzureCLI@2
    displayName: Sign packages with Sign CLI
    inputs:
      azureSubscription: '$(SignServiceConnection)'
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      inlineScript: |
        .\sign code azure-key-vault '**/*.nupkg' `
          --base-directory "$(Pipeline.Workspace)\BuildLinuxCUDAPackages" `
          --file-list "$(Pipeline.Workspace)\config\signedfiles.txt" `
          --azure-key-vault-url "$(SignVaultURL)" `
          --publisher-name "TorchSharp" `
          --description "TorchSharp" `
          --description-url "https://github.com/dotnet/TorchSharp" `
          --azure-key-vault-certificate "$(SignCertFriendlyName)"

  # CHANGED: Use PublishBuildArtifacts for signed Linux CUDA packages
  - task: PublishBuildArtifacts@1
    displayName: Publish Signed Linux CUDA Packages (Build Artifact)
    inputs:
      pathToPublish: $(Pipeline.Workspace)/BuildLinuxCUDAPackages
      artifactName: SignedLinuxCUDAPackages
      parallel: false
    continueOnError: true

  - script: rmdir /s /q  $(Pipeline.Workspace)\BuildLinuxCUDAPackages
    displayName: Free up space (TorchSharp packages in workspace)

################################################################################
- job: Push_TorchSharp_And_libtorch_cpu_Packages
################################################################################
  condition: and(eq('${{ parameters.PushPackagesToFeed }}', true), ne(variables['system.pullrequest.isfork'], true), eq(variables['build.sourcebranchname'], '${{ parameters.SourceBranchName }}'))
  dependsOn:
  - Build_TorchSharp_And_libtorch_cpu_Packages
  - CodeSign_Core
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'windows-latest'
  steps:

  # Push packages to feed
  #
  # Doing these one by one as we're getting a lot of failures pushing them
  # Also replaying them multiple times for the same reason
  #
  - task: NuGetAuthenticate@0
    displayName: 'NuGet Authenticate'

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download Signed TorchSharp Packages (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'SignedTorchSharpPackages'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  - task: NuGetCommand@2
    displayName: 'NuGet push (TorchSharp)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/TorchSharp.*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
    continueOnError: true

  - task: NuGetCommand@2
    displayName: 'NuGet push (TorchAudio)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/TorchAudio.*.nupkg'
      publishVstsFeed: 'TorchSharp/SignedPackages'
      allowPackageConflicts: true
    continueOnError: true

  - task: NuGetCommand@2
    displayName: 'NuGet push (TorchVision)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/TorchVision.*.nupkg'
      publishVstsFeed: 'TorchSharp/SignedPackages'
      allowPackageConflicts: true
    continueOnError: true

  - task: NuGetCommand@2
    displayName: 'NuGet push (TorchSharp-cpu)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/TorchSharp-*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
    continueOnError: true

  # push the CPU runtime packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (libtorch-cpu)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/libtorch-cpu*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
    continueOnError: true

  # push the CPU runtime packages (retry - we get so many failures!)
  - task: NuGetCommand@2
    displayName: 'NuGet push (libtorch-cpu - retry)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/libtorch-cpu*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
    continueOnError: true

  # push the CPU runtime packages (retry - we get so many failures!)
  - task: NuGetCommand@2
    displayName: 'NuGet push (libtorch-cpu - retry)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/libtorch-cpu*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
    continueOnError: true

  # Terminate all dotnet build processes.
  - script: dotnet build-server shutdown
    displayName: Dotnet Server Shutdown


################################################################################
# Only run if BuildLibTorchPackages is true
- job: Push_libtorch_cuda_win_Packages
################################################################################
  condition: and(eq('${{ parameters.BuildLibTorchPackages }}', true), eq('${{ parameters.PushPackagesToFeed }}', true), ne(variables['system.pullrequest.isfork'], true))
  dependsOn:
  - Build_libtorch_cuda_win_Packages
  - CodeSign_Extras
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'windows-latest'
  steps:

  # Push packages to feed
  #
  # Doing these one by one as we're getting a lot of failures pushing them
  # Also replaying them multiple times for the same reason
  #
  - task: NuGetAuthenticate@0
    displayName: 'NuGet Authenticate'

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download Signed Windows CUDA Packages (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'SignedWinCUDAPackages'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # push the Windows Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda win-x64)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*win*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Windows Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda win-x64 retry)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*win*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Windows Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda win-x64 retry)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*win*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Windows Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda win-x64 retry)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*win*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Windows Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda win-x64 retry)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*win*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true


################################################################################
- job: Push_libtorch_cuda_linux_Packages
################################################################################
  condition: and(eq('${{ parameters.BuildLibTorchPackages }}', 'true'), eq('${{ parameters.PushPackagesToFeed }}', true), ne(variables['system.pullrequest.isfork'], true))
  dependsOn:
  - Build_libtorch_cuda_linux_Packages
  - CodeSign_Extras
  variables:
    BuildConfig: Release
    OfficialBuildId: $(BUILD.BUILDNUMBER)
    DOTNET_CLI_TELEMETRY_OPTOUT: 1
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
    DOTNET_MULTILEVEL_LOOKUP: 0
  pool:
    vmImage: 'windows-latest'
  # container: UbuntuContainer
  # Exact copy of the dependency install above - TODO share this somewhere
  steps:

  # Push packages to feed
  #
  # Doing these one by one as we're getting a lot of failures pushing them
  # Also replaying them multiple times for the same reason
  #
  - task: NuGetAuthenticate@0
    displayName: 'NuGet Authenticate'

  # CHANGED: Use DownloadBuildArtifacts instead of download
  - task: DownloadBuildArtifacts@1
    displayName: Download Signed Linux CUDA Packages (Build Artifact)
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'SignedLinuxCUDAPackages'
      downloadPath: $(Pipeline.Workspace)
    retryCountOnTaskFailure: 3

  # push the Linux Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda linux-x64)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*linux*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Linux Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda linux-x64)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*linux*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Linux Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda linux-x64)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*linux*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true

  # push the Linux Cuda packages
  - task: NuGetCommand@2
    displayName: 'NuGet push (cuda linux-x64)'
    inputs:
      command: push
      packagesToPush:  '$(Pipeline.Workspace)/**/*cuda*linux*.nupkg'
      publishVstsFeed: 'TorchSharp/TestPackages'
      allowPackageConflicts: true
      # often fails - try but ignore the error until we sort it out
    continueOnError: true